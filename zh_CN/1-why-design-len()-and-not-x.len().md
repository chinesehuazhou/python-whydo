# Python 为什么用 len() 函数，不用 x.len() 风格？

为什么 Python 要用 len 括号 x  这种内置函数的写法，而不像其它的面向对象语言，用 x 点 len 括号 的写法？

三个主要的原因：

原因一：将 len 设计成内置函数，直接读取底层的 C 结构体，这样速度会更快。

这个原因在《流畅的 Python》这本书中有所介绍。

> 我在 2013 年问核心开发者 Raymond Hettinger 这个问题时，他用“Python 之禅”里的原话回答了我：“实用胜于纯粹。”在 1.2 节里我提到过，如果 x是一个内置类型的实例，那么 len(x)的速度会非常快。背后的原因是 CPython 会直接从一个 C 结构体里读取对象的长度，完全不会调用任何方法。获取一个集合中元素的数量是一个很常见的操作，在 str、list、memoryview等类型上，这个操作必须高效。
> 换句话说，len之所以不是一个普通方法，是为了让 Python 自带的数据结构可以走后门，abs也是同理。但是多亏了它是特殊方法，我们也可以把 len用于自定义数据类型。这种处理方式在保持内置类型的效率和保证语言的一致性之间找到了一个平衡点，也印证了“Python 之禅”中的另外一句话：“不能让特例特殊到开始破坏既定规则。”
> 如果把abs和 len都看作一元运算符的话，你也许更能接受它们——虽然看起来像面向对象语言中的函数，但实际上又不是函数。有一门叫作 ABC 的语言是 Python 的直系祖先，它内置了一个 \#运算符，当你写出 \#s的时候，它的作用跟 len一样。如果写成 x#s这样的中缀运算符的话，那么它的作用是计算 s中 x出现的次数。在 Python 里对应的写法是 s.count(x)。注意这里的 s是一个序列类型。
> ——出自该书《1.4　为什么len不是普通方法》

原因二：前缀符号更可读，简单胜过复杂！

原因三：见名知意，看见 len 函数就知道它是用来求长度的。但是看见 x.len() 方法，它实际可能并不是求长度，只是恰好叫这个名字！

后两个原因是我转述了 Python 之父的解释。

除此之外，我还有自己的观点：我认为这是对世界本质的洞察！求长度是一种共性操作，就像分数 ½ 中的横线，与具体对象无关！所以，就应该设计成一个内置函数！

-------------------
## 原题：len(x) 击败 x.len()，从内置函数看 Python 的设计思想

内置函数是 Python 的一大特色，用极简的语法实现很多常用的操作。

它们预先定义在内置命名空间中，开箱即用，所见即所得。Python 被公认是一种新手友好型的语言，这种说法能够成立，内置函数在其中起到了极关键的作用。

举个例子，求字符串 x 的长度，Python 的写法是 len(x) ，而且这种写法对列表、元组和字典等对象也同样适用，只需要传入对应的参数即可。len() 函数是共用的。

这是一种极简哲学的体现：**Simple is better than complex。** 

但是，有些语言并不是这样，例如在 Java 中，字符串类有一个求长度的方法，其它类也有自己的求长度的方法，它们无法共用。每次使用时，通过类或实例来调用。

同样是求字符串长度，Python 的写法：

```python
saying = "Hello world!"
print(len(saying))

# 结果：12
```

而在 Java 中，写法可能如下（简化起见）：

```java
String saying = "Hello world!";
System.out.println(saying.length());

// 结果：12
```

Python 采用的是一种**前缀表达式** ，而 Java 采用的则是**后缀表达式** 。

除了求长度，Python 的某些内置函数也能在 Java 中找到对应的表达。例如，数值型字符串 s 转化为整型数字，Python 可以用 `int(s)` 函数，而 Java 可以用 `Integer.parseInt(s)` ；整型数字转化为字符串，Python 可以用 `str(i)` ，而 Java 也有 `String.valueOf(i)` 。

Python 的内置函数不与特定的类绑定，它们是一级对象。而 Java 的“函数”则无法脱离类而存在，它们只是附属品。

从直观角度来看，Python 的表达似乎是更优的。但是，它们**并不具有可比性** ，因为这是两套语言系统，各有独特的范畴背景，并不能轻易地化约。

就好比是，不能因为拉丁字母笔画简单，就说它优于汉字，因为在表意时，字母（表音文字）是远逊于汉字（表意文字）的。同样的，日本借用了汉字的偏旁部首而造出来的文字，虽然更省笔墨，但是也完全丧失了意蕴。

以此类比，Python 的内置函数虽有简便之美，但却丢失了某些表意功能。有些人在质疑/抨击 Python 的时候，也喜欢拿这点说事，认为这是 Python 的设计缺陷。

这就引出本文最想讨论的一个问题来：**为什么 Python 要设计成 len(x) 这种前缀表达，而不是 x.len() 这样的后缀表达呢？** 

事实上，后缀设计也是可行的，以 Python 中列表的两个方法为例：

```python
mylist = [2, 1, 3, 5, 4]

mylist.sort()
print(mylist)   # [1, 2, 3, 4, 5]

mylist.reverse()
print(mylist)   # [5, 4, 3, 2, 1]
```

它们都是通过列表对象来调用，并不是凭空从内置命名空间中拿来的。语义表达得也很清楚，就是对 mylist 做排序和逆转。

恰恰那么巧，它们还有两个同父异母的兄弟 sorted() 与 reversed()，这俩是前缀表达型。

```python
mylist = [2, 1, 3, 5, 4]

sort_list = sorted(mylist)
print(sort_list)   # [1, 2, 3, 4, 5]

reverse_list = reversed(mylist)
print(list(reverse_list))   # [4, 5, 3, 1, 2]
```

不同的写法，都在做同一件事（不考虑它们的副作用）。因此，后缀语法并非不可行，之所以不用，那肯定是刻意的设计。

回到前面的问题：为什么是 len(x) ，而不是 x.len(x)，这根源于 Python 的什么设计思想呢？ 

Python 之父 **Guido van Rossum** 曾经解释过这个问题（ #TODO: add link），有两个原因：

- 对于某些操作，前缀符比后缀更好读——前缀（和中缀）表示法在数学中有着悠久的历史，其视觉效果有助于数学家思考问题。我们可以简单地把公式 `x*(a + b)`  重写成 `x*a + x*b` ，但同样的事，以原生的面向对象的方式实现，就比较笨拙。
- 当读到 len(x) 时，我就 **知道** 这是在求某对象的长度。它告诉我了两点：返回值是一个整数，参数是某种容器。但当读到 x.len() 时，我必须事先知道某种容器 x，它实现了一个接口，或者继承了一个拥有标准 len() 方法的类。我们经常会目睹到这种混乱：一个类并没有实现映射（mapping）接口，却拥有 get() 或 keys() 方法，或者某些非文件对象，却拥有一个 write() 方法。

解释完这两个原因之后，Guido 还总结成一句话说：“I see 'len' as a built-in *operation* ”。这已经不仅是在说 len() 更可读易懂了，而完全是在拔高 len() 的地位。

这就好比说，分数 ½ 中的横线是数学中的一个“内置”表达式，并不需要再实现什么接口之类的，它自身已经表明了“**某数除以某数** ”的意思。不同类型的数（整数、浮点数、有理数、无理数...）共用同一个操作符，不必为每类数据实现一种求分数的操作。

**优雅易懂是 Python 奉行的设计哲学** ，len() 函数的前缀表达方式是最好的体现。我想起 Guido 对“**为什么索引从 0 开始** ”的解释。其最重要的原因，也正是 0-based 索引最优雅易懂。

> 出自《[The History of Python: Why Python uses 0-based indexing](https://python-history.blogspot.com/2013/10/why-python-uses-0-based-indexing.html)》
> 
> 让我们来先看看切片的用法。可能最常见的用法，就是“取前 n 位元素”或“从第i 位索引起，取后 n 位元素”(前一种用法，实际上是 i == 起始位的特殊用法)。如果这两种用法实现时可以不在表达式中出现难看的 +1 或 -1，那将会非常的优雅。
>
> 使用 0-based 的索引方式、半开区间切片和缺省匹配区间的话（Python最终采用这样的方式），上面两种情形的切片语法就变得非常漂亮：a[:n] 和 a[i:i+n]，前者是 a[0:n] 的缩略写法。

所以，我们能说 len(x) 击败 x.len() ，支撑它的是一种化繁为简、纯粹却深邃的设计思想。

面向对象的编程语言自发明时起，就想模拟我们生活于其中的现实世界。可是什么类啊、接口啊、对象啊、以及它们的方法啊，这些玩意的毒，有时候蒙蔽了我们去看见世界本质的眼睛。

桌子类有桌子类的求长度方法，椅子类有椅子类的求长度方法，无穷无尽，可现实真是如此么？求长度的方法就不能是一种独立存在的对象么？它之所以存在，是因为有“对象”存在，而不是因为有某个类才存在啊。

所以，我想说，len(x) 击败 x.len()，这还体现了 **Python 对世界本质的洞察** 。 

求某个对象的长度，这种操作独立于对象之外而存在，并不是该对象内部所有的一种属性或功能。从这个角度理解，我们能够明白，**为什么 Python 要设计出内置函数？** 内置函数其实是对世界本质的一种捕捉。

这些见微知著的发现，足够使我们爱上这门语言了。人生苦短，我用 Python。
